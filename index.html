<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Star Spectra Viewer</title>
  <link rel="stylesheet" href="main.css">
</head>

<body>
  <header>
    <h2 style="margin:.1rem">ðŸŒŒ Star Spectra Viewer</h2>
  </header>

  <div id="controls" aria-live="polite">
    <label for="spectralSlider">Spectral Type:</label>
    <input type="range" id="spectralSlider" min="0" max="0" step="1" value="0" aria-label="Spectral type slider">
    <span id="sliderLabel">â€”</span>
    <div id="message" role="status">Initializingâ€¦</div>
    <button id="keepLineBtn">Keep Line</button>
    <button id="clearLinesBtn">Clear Lines</button>
  </div>

  <div id="canvas-container">
    <canvas id="spectrumCanvas"></canvas>
    <canvas id="canvasRainbow" style="height:40px; margin-top:4px;"></canvas>
  </div>

  <footer>
    Spectral types based on Kesseli et al. (2017),
    <a href="https://arxiv.org/abs/1702.06957">arXiv:1702.06957</a>
    and the SDSS BOSS Spectrograph Empirical Templates
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', () => init());

    const canvas = document.getElementById('spectrumCanvas');
    const ctx = canvas.getContext('2d');
    const slider = document.getElementById('spectralSlider');
    const sliderLabel = document.getElementById('sliderLabel');
    const messageEl = document.getElementById('message');

    let spectraData = {};
    let keys = [];
    let currentKey = null;
    let hoverLineX = null;      // Current hover line (while moving)
    let persistentLineX = null; // Last clicked/touched line
    let savedLines = [];        // Permanent lines (from "Keep Line")
    const marginBottom = 60;    // px for scale and labels
    const topPadding = 40;
    let plotHeight;

    async function init() {
      makeCanvasSizing();
      await loadSpectraWithFallbacks();
      slider.addEventListener('input', () => {
        const idx = parseInt(slider.value, 10);
        if (keys[idx]) loadSpectrum(keys[idx]);
      });
    }

    function makeCanvasSizing() {
      function resize() {
        canvas.width = Math.floor(canvas.clientWidth * devicePixelRatio);
        canvas.height = Math.floor(canvas.clientHeight * devicePixelRatio);
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
        if (currentKey) {
          drawSpectrum(spectraData[currentKey]);
          drawSpectrumRainbow(spectraData[currentKey], document.getElementById('canvasRainbow'));
        }
      }
      window.addEventListener('resize', debounce(resize, 120));
      resize();
    }

    function getVisibleSpectrum(spectrum, visibleMin = 380, visibleMax = 780) {
      if (!spectrum || !spectrum.wavelength || !spectrum.flux) return null;

      const wl = spectrum.wavelength;
      const fx = spectrum.flux;
      if (wl.length !== fx.length || wl.length < 2) return null;

      // filter to visible range
      const visibleIndices = wl.map((w, i) => (w >= visibleMin && w <= visibleMax ? i : -1))
        .filter(i => i >= 0);
      if (visibleIndices.length < 2) return null;

      const wlVis = visibleIndices.map(i => wl[i]);
      const fxVis = visibleIndices.map(i => fx[i]);
      const maxF = Math.max(...fxVis) || 1;

      return { wl: wlVis, fx: fxVis, maxF, minW: visibleMin, maxW: visibleMax };
    }

    function drawSpectrum(spectrum) {
      const visible = getVisibleSpectrum(spectrum);
      if (!visible) {
        showMessage('No data in visible spectrum range (380â€“780nm).', true);
        return;
      }

      const { wl, fx, maxF, minW, maxW } = visible;

      // canvas sizing
      const cw = canvas.clientWidth || 600;
      const ch = canvas.clientHeight || 400;
      canvas.width = Math.floor(cw * devicePixelRatio);
      canvas.height = Math.floor(ch * devicePixelRatio);
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      ctx.clearRect(0, 0, cw, ch);

      plotHeight = Math.max(0, ch - marginBottom - topPadding);
      const rainbowTop = topPadding;
      const rainbowBottom = topPadding + plotHeight;

      ctx.lineWidth = 1;
      ctx.lineCap = 'round';

      // draw spectrum as segments
      for (let i = 0; i < wl.length - 1; i++) {
        const x1 = ((wl[i] - minW) / (maxW - minW)) * cw;
        const x2 = ((wl[i + 1] - minW) / (maxW - minW)) * cw;
        const y1 = rainbowTop + (1 - fx[i] / maxF) * plotHeight;
        const y2 = rainbowTop + (1 - fx[i + 1] / maxF) * plotHeight;

        ctx.strokeStyle = wavelengthToRGBString(wl[i]);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      // title
      ctx.fillStyle = '#ddd';
      ctx.font = '12px system-ui, sans-serif';
      ctx.textBaseline = 'top';
      ctx.fillText(`Spectral Type: ${currentKey} â€” ${minW}â€“${maxW}nm`, 8, 8);

      // wavelength scale
      drawWavelengthScale(minW, maxW, ctx, cw, ch, marginBottom);

      // hover line
      if (hoverLineX !== null) {
        ctx.save();
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = "red";
        ctx.beginPath();
        ctx.moveTo(hoverLineX, rainbowTop);
        ctx.lineTo(hoverLineX, rainbowBottom);
        ctx.stroke();
        ctx.restore();
      }

      // persistent line
      if (persistentLineX !== null) {
        ctx.strokeStyle = "red";
        ctx.beginPath();
        ctx.moveTo(persistentLineX, rainbowTop);
        ctx.lineTo(persistentLineX, rainbowBottom);
        ctx.stroke();
      }

      // saved lines
      for (let x of savedLines) {
        ctx.strokeStyle = "red";
        ctx.beginPath();
        ctx.moveTo(x, rainbowTop);
        ctx.lineTo(x, rainbowBottom);
        ctx.stroke();
      }
    }

    function drawWavelengthScale(minW, maxW, ctx, cw, ch, marginBottom) {
      const range = Math.max(1e-6, maxW - minW);
      const axisBottom = ch - marginBottom + 2; // baseline for ticks (labels go below)
      const pixels = cw;

      function chooseMajorStep(range, pixels, minLabelSpacing = 60) {
        const targetLabels = Math.max(2, Math.floor(pixels / minLabelSpacing));
        const rough = range / targetLabels;
        const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
        const candidates = [1, 2, 5, 10];
        let best = candidates[0] * pow10;
        let bestDiff = Infinity;
        for (const c of candidates) {
          const step = c * pow10;
          const diff = Math.abs(step - rough);
          if (diff < bestDiff) { best = step; bestDiff = diff; }
        }
        return best;
      }

      const majorStep = chooseMajorStep(range, pixels, 60);
      const minorStep = majorStep / 10;

      ctx.strokeStyle = '#888';
      ctx.fillStyle = '#ddd';
      ctx.lineWidth = 1;
      ctx.font = '12px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      const pixelsPerMajor = (majorStep / range) * cw;
      const minPixelSpacing = 56;
      const labelSkip = Math.max(1, Math.ceil(minPixelSpacing / pixelsPerMajor));

      let majorIndex = 0;
      const startMajor = Math.ceil(minW / majorStep) * majorStep;
      const endMajor = Math.floor(maxW / majorStep) * majorStep;
      for (let w = startMajor; w <= endMajor + 1e-9; w += majorStep) {
        const x = ((w - minW) / range) * cw;
        ctx.beginPath();
        ctx.moveTo(x, axisBottom);
        ctx.lineTo(x, axisBottom - 10);
        ctx.stroke();

        if (majorIndex % labelSkip === 0) {
          ctx.fillText(String(Math.round(w)), x, axisBottom + 2);
        }
        majorIndex++;
      }

      const startMinor = Math.ceil(minW / minorStep) * minorStep;
      for (let w = startMinor; w <= maxW + 1e-9; w += minorStep) {
        if (Math.abs((w / majorStep) - Math.round(w / majorStep)) < 1e-6) continue;
        const x = ((w - minW) / range) * cw;
        ctx.beginPath();
        ctx.moveTo(x, axisBottom);
        ctx.lineTo(x, axisBottom - 6);
        ctx.stroke();
      }
    }

    function wavelengthToRGBString(wavelength) {
      let r = 0, g = 0, b = 0, factor = 0;
      if (wavelength >= 380 && wavelength < 440) { r = -(wavelength - 440) / (440 - 380); g = 0; b = 1; }
      else if (wavelength >= 440 && wavelength < 490) { r = 0; g = (wavelength - 440) / (490 - 440); b = 1; }
      else if (wavelength >= 490 && wavelength < 510) { r = 0; g = 1; b = -(wavelength - 510) / (510 - 490); }
      else if (wavelength >= 510 && wavelength < 580) { r = (wavelength - 510) / (580 - 510); g = 1; b = 0; }
      else if (wavelength >= 580 && wavelength < 645) { r = 1; g = -(wavelength - 645) / (645 - 580); b = 0; }
      else if (wavelength >= 645 && wavelength <= 780) { r = 1; g = 0; b = 0; }
      else { r = g = b = 0; }

      if (wavelength >= 380 && wavelength < 420) factor = 0.3 + 0.7 * (wavelength - 380) / 40;
      else if (wavelength >= 420 && wavelength <= 700) factor = 1.0;
      else if (wavelength > 700 && wavelength <= 780) factor = 0.3 + 0.7 * (780 - wavelength) / 80;
      else factor = 0.0;

      const gamma = 0.8;
      const R = Math.round(Math.pow(Math.max(0, r * factor), gamma) * 255 + 10);
      const G = Math.round(Math.pow(Math.max(0, g * factor), gamma) * 255 + 10);
      const B = Math.round(Math.pow(Math.max(0, b * factor), gamma) * 255 + 10);
      return `rgb(${R},${G},${B})`;
    }

    function debounce(fn, ms) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; }

    async function tryFetchJSON(path) {
      try {
        const res = await fetch(path, { cache: "no-cache" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return { path, json: await res.json() };
      } catch (err) {
        console.warn('fetch failed', path, err);
        return { path, error: err };
      }
    }

    /**
     * DRAW RAINBOW into an offscreen buffer and paint the buffer to the visible canvas.
     * The offscreen buffer is stored on canvasRainbow._rainbowBuffer so magnifier can reuse it.
     */
    function drawSpectrumRainbow(spectrum, canvasRainbow) {
      const visible = getVisibleSpectrum(spectrum);
      if (!visible) return;

      const { wl, fx, maxF, minW, maxW } = visible;

      // CSS sizes
      const cw = Math.max(1, canvasRainbow.clientWidth);
      const ch = Math.max(1, canvasRainbow.clientHeight);

      const dpr = devicePixelRatio || 1;
      const bufW = Math.max(1, Math.floor(cw * dpr));
      const bufH = Math.max(1, Math.floor(ch * dpr));

      const buf = document.createElement('canvas');
      buf.width = bufW;
      buf.height = bufH;
      const bctx = buf.getContext('2d');
      bctx.clearRect(0, 0, bufW, bufH);

      for (let i = 0; i < bufW; i++) {
        const w = minW + (i / (bufW - 1)) * (maxW - minW);
        let idx = wl.findIndex(v => v >= w);
        if (idx < 0) idx = wl.length - 1;
        const f = (fx[idx] || 0) / maxF;

        const rgb = wavelengthToRGBObj(w);
        let r = Math.round(Math.max(0, Math.min(255, rgb.r * f)));
        let g = Math.round(Math.max(0, Math.min(255, rgb.g * f)));
        let b = Math.round(Math.max(0, Math.min(255, rgb.b * f)));

        if (Math.abs(r - g) < 2 && Math.abs(g - b) < 2) {
          const gray = Math.min(255, Math.round(40 + 200 * f));
          r = g = b = gray;
        }

        bctx.fillStyle = `rgb(${r},${g},${b})`;
        bctx.fillRect(i, 0, 1, bufH);
      }

      canvasRainbow._rainbowBuffer = buf;

      const ctxR = canvasRainbow.getContext('2d');
      canvasRainbow.width = bufW;
      canvasRainbow.height = bufH;
      ctxR.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctxR.clearRect(0, 0, cw, ch);
      ctxR.drawImage(buf, 0, 0, bufW, bufH, 0, 0, cw, ch);
    }


    /**
     * Enable magnifier on a canvasRainbow element using the buffer produced by drawSpectrumRainbow.
     * Listeners are added once; subsequent calls update the stored buffer (so magnifier uses latest).
     */
    function enableMagnifier(canvasRainbow, spectrum) {
      if (!canvasRainbow) return;
      const ctxR = canvasRainbow.getContext('2d');
      const dpr = devicePixelRatio || 1;

      // Avoid adding listeners multiple times â€” mark the element
      if (!canvasRainbow._magnifierInstalled) {
        function drawMagnifierAt(clientX) {
          const rect = canvasRainbow.getBoundingClientRect();
          const cw = Math.max(1, canvasRainbow.clientWidth);
          const ch = Math.max(1, canvasRainbow.clientHeight);
          const xCSS = clientX - rect.left;
          if (xCSS < 0 || xCSS > cw) return;

          const buf = canvasRainbow._rainbowBuffer;
          if (!buf) return;

          // Ensure transform is set so we draw in CSS coordinates
          ctxR.setTransform(dpr, 0, 0, dpr, 0, 0);

          // redraw base rainbow from buffer
          ctxR.clearRect(0, 0, cw, ch);
          ctxR.drawImage(buf, 0, 0, buf.width, buf.height, 0, 0, cw, ch);

          // draw vertical indicator on main rainbow showing exact position
          ctxR.save();
          ctxR.globalAlpha = 0.9;
          ctxR.strokeStyle = 'rgba(255,80,0,0.9)';
          ctxR.lineWidth = 2;
          const indicatorX = xCSS;
          ctxR.beginPath();
          ctxR.moveTo(indicatorX, 0);
          ctxR.lineTo(indicatorX, ch);
          ctxR.stroke();
          ctxR.restore();

          // magnifier geometry (CSS units)
          const magWidth = 140;
          const magHeight = 84;
          const margin = 0;
          const magX = Math.min(cw - magWidth - margin, xCSS + 15);
          const magY = margin;
          const zoom = 4;

          // white background + border
          ctxR.fillStyle = "rgba(255,255,255,0.95)";
          ctxR.fillRect(magX - 1, magY - 1, magWidth + 2, magHeight + 2);
          ctxR.strokeStyle = "#333";
          ctxR.lineWidth = 1;
          ctxR.strokeRect(magX - 1, magY - 1, magWidth + 2, magHeight + 2);

          // compute source rectangle in buffer (device pixels)
          const centerBufX = (xCSS / cw) * buf.width;
          // source width in CSS coords is magWidth / zoom; convert to buffer (device) pixels
          const srcWidthBuf = Math.max(1, Math.floor((magWidth / zoom) * dpr));
          let srcX = Math.round(centerBufX - srcWidthBuf / 2);
          srcX = Math.max(0, Math.min(buf.width - srcWidthBuf, srcX));
          const srcY = 0;
          const srcH = buf.height;

          // destination inside magnifier (leave small area for label/tick)
          const destW = magWidth;
          const destH = magHeight - 20;

          // draw high-resolution slice into magnifier using drawImage (preserves detail)
          ctxR.drawImage(buf, srcX, srcY, srcWidthBuf, srcH, magX, magY, destW, destH);

          // tickmark inside magnifier (center)
          const tickX = magX + destW / 2;
          ctxR.strokeStyle = "black";
          ctxR.lineWidth = 1;
          ctxR.beginPath();
          ctxR.moveTo(tickX, magY);
          ctxR.lineTo(tickX, magY + destH);
          ctxR.stroke();

          // Get visible spectrum using the helper
          const visible = getVisibleSpectrum(spectrum);
          if (!visible) return;

          const { wl, fx, minW, maxW } = visible; // minW/maxW = restricted to 380â€“780 nm

          // map xCSS (column in canvas) to wavelength in visible range
          const centerWavelength = minW + (xCSS / cw) * (maxW - minW);

          const text = `${Math.round(centerWavelength)} nm`;
          const textMetrics = ctxR.measureText(text);

          const textWidth = textMetrics.width;
          const textHeight = 12; // approximate height for 12px font

          // Draw semi-transparent dark gray rectangle behind text
          ctxR.fillStyle = "rgba(50,50,50,0.5)"; // dark gray, 50% opacity
          ctxR.fillRect(magX + 6, magY + destH - 40, textWidth + 4, textHeight + 4); // small padding

          // draw label
          ctxR.fillStyle = "white";
          ctxR.font = "12px system-ui, sans-serif";

          ctxR.textBaseline = 'top';
          ctxR.fillText(text, magX + 6 + 2, magY + destH - 40 + 2); // offset slightly for padding
        }

        // pointer handlers: unify mouse & touch using clientX
        function onMovePointer(e) {
          if (e.touches && e.touches.length) {
            drawMagnifierAt(e.touches[0].clientX);
          } else {
            drawMagnifierAt(e.clientX);
          }
        }
        function onLeave() {
          // redraw base only (clear magnifier)
          const buf = canvasRainbow._rainbowBuffer;
          if (buf) {
            const cw = Math.max(1, canvasRainbow.clientWidth);
            const ch = Math.max(1, canvasRainbow.clientHeight);
            // ensure proper transform
            ctxR.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctxR.clearRect(0, 0, cw, ch);
            ctxR.drawImage(buf, 0, 0, buf.width, buf.height, 0, 0, cw, ch);
          } else {
            ctxR.clearRect(0, 0, canvasRainbow.clientWidth, canvasRainbow.clientHeight);
          }
        }

        canvasRainbow.addEventListener('mousemove', onMovePointer, { passive: true });
        canvasRainbow.addEventListener('touchstart', onMovePointer, { passive: true });
        canvasRainbow.addEventListener('touchmove', onMovePointer, { passive: false });
        canvasRainbow.addEventListener('mouseleave', onLeave);
        canvasRainbow.addEventListener('touchend', onLeave);
        canvasRainbow._magnifierInstalled = true;
      }
    }



    async function loadSpectraWithFallbacks() {
      showMessage('Loading spectraâ€¦');

      const candidates = ['spectra.json'];
      let result = null;
      for (const p of candidates) {
        result = await tryFetchJSON(p);
        if (result && result.json) break;
      }

      if (!result || result.error) {
        showMessage('Could not load any spectra JSON.', true);
        return;
      }

      spectraData = normalizeSpectra(result.json);
      keys = Object.keys(spectraData).sort(spectralComparator);

      if (keys.length === 0) {
        showMessage('JSON loaded but no spectra found.', true);
        return;
      }

      slider.max = keys.length - 1;
      slider.value = 0;
      sliderLabel.textContent = keys[0];
      loadSpectrum(keys[0]);
      showMessage(``);
    }

    function normalizeSpectra(raw) {
      const normalized = {};
      if (Array.isArray(raw)) {
        raw.forEach((entry, i) => normalized[String(i)] = entry);
      } else if (typeof raw === 'object') {
        for (const k in raw) normalized[k] = raw[k];
      }
      return normalized;
    }

    function spectralComparator(a, b) {
      const spectralOrder = ['L', 'T', 'M', 'K', 'G', 'F', 'A', 'B', 'O'];
      const matchA = a.match(/^([LTMKGFABO])(\d+)?/);
      const matchB = b.match(/^([LTMKGFABO])(\d+)?/);
      if (!matchA || !matchB) return 0;
      const idxA = spectralOrder.indexOf(matchA[1]);
      const idxB = spectralOrder.indexOf(matchB[1]);
      if (idxA !== idxB) return idxA - idxB;
      const nA = matchA[2] ? parseInt(matchA[2], 10) : 0;
      const nB = matchB[2] ? parseInt(matchB[2], 10) : 0;
      return nB - nA;
    }

    function loadSpectrum(key) {
      if (!spectraData[key]) return;
      currentKey = key;
      sliderLabel.textContent = key;
      drawSpectrum(spectraData[key]);
      drawSpectrumRainbow(spectraData[key], document.getElementById('canvasRainbow'));
      enableMagnifier(document.getElementById('canvasRainbow'), spectraData[key]);
    }

    function showMessage(txt, isErr = false) {
      messageEl.textContent = txt;
      messageEl.style.color = isErr ? 'var(--err)' : 'var(--muted)';
    }

    function wavelengthToRGBObj(wavelength) {
      let r = 0, g = 0, b = 0, factor = 0;

      if (wavelength >= 380 && wavelength < 440) { r = -(wavelength - 440) / (440 - 380); g = 0; b = 1; }
      else if (wavelength >= 440 && wavelength < 490) { r = 0; g = (wavelength - 440) / (490 - 440); b = 1; }
      else if (wavelength >= 490 && wavelength < 510) { r = 0; g = 1; b = -(wavelength - 510) / (510 - 490); }
      else if (wavelength >= 510 && wavelength < 580) { r = (wavelength - 510) / (580 - 510); g = 1; b = 0; }
      else if (wavelength >= 580 && wavelength < 645) { r = 1; g = -(wavelength - 645) / (645 - 580); b = 0; }
      else if (wavelength >= 645 && wavelength <= 780) { r = 1; g = 0; b = 0; }
      else { r = g = b = 0; }

      if (wavelength >= 380 && wavelength < 420) factor = 0.3 + 0.7 * (wavelength - 380) / 40;
      else if (wavelength >= 420 && wavelength <= 700) factor = 1.0;
      else if (wavelength > 700 && wavelength <= 780) factor = 0.3 + 0.7 * (780 - wavelength) / 80;
      else factor = 0.0;

      const gamma = 0.8;
      // compute, clamp, round
      const R = Math.round(Math.max(0, Math.min(255, Math.pow(Math.max(0, r * factor), gamma) * 255 + 10)));
      const G = Math.round(Math.max(0, Math.min(255, Math.pow(Math.max(0, g * factor), gamma) * 255 + 10)));
      const B = Math.round(Math.max(0, Math.min(255, Math.pow(Math.max(0, b * factor), gamma) * 255 + 10)));

      return { r: R, g: G, b: B };
    }
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const rainbowTop = topPadding;
      const rainbowBottom = topPadding + plotHeight;

      if (my >= rainbowTop && my <= rainbowBottom) {
        hoverLineX = mx;
      } else {
        hoverLineX = null;
      }

      drawSpectrum(spectraData[currentKey]); // Force redraw immediately

      console.log("work");
    });

    canvas.addEventListener("click", () => {
      if (hoverLineX !== null) {
        persistentLineX = hoverLineX;
        savedLines.push(persistentLineX);
      }
    });

    document.getElementById("keepLineBtn").addEventListener("click", () => {
      if (persistentLineX !== null) {
        savedLines.push(persistentLineX);
      }
    });

    document.getElementById("clearLinesBtn").addEventListener("click", () => {
      savedLines = [];
      persistentLineX = null;
      drawSpectrum(spectraData[currentKey]);
    });

  </script>
</body>

</html>