<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Star Spectra Viewer</title>
  <link rel="stylesheet" href="main.css">
</head>

<body>
  <header>
    <h2 style="margin:.1rem">🌌 Star Spectra Viewer</h2>
  </header>

  <!-- ⭐ Slider controls -->
  <div id="controls" aria-live="polite">
    <label for="spectralSlider">Spectral Type:</label>
    <input type="range" id="spectralSlider" min="0" max="0" step="1" value="0" aria-label="Spectral type slider">
    <span id="sliderLabel">—</span>
    <div id="message" role="status">Initializing…</div>
  </div>

  <!-- ⭐ Canvas area -->
  <div id="canvas-container">
    <canvas id="spectrumCanvas"></canvas>
    <canvas id="canvasRainbow" style="height:20px; margin-top:4px;"></canvas>
  </div>

  <footer>
    Spectral types based on Kesseli et al. (2017),
    <a href="https://arxiv.org/abs/1702.06957">arXiv:1702.06957</a>
    and the SDSS BOSS Spectrograph Empirical Templates
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', () => init());

    const canvas = document.getElementById('spectrumCanvas');
    const ctx = canvas.getContext('2d');
    const slider = document.getElementById('spectralSlider');
    const sliderLabel = document.getElementById('sliderLabel');
    const messageEl = document.getElementById('message');

    let spectraData = {};
    let keys = [];
    let currentKey = null;

    async function init() {
      makeCanvasSizing();
      await loadSpectraWithFallbacks();
      slider.addEventListener('input', () => {
        const idx = parseInt(slider.value, 10);
        if (keys[idx]) loadSpectrum(keys[idx]);
      });
    }

    function makeCanvasSizing() {
      function resize() {
        canvas.width = Math.floor(canvas.clientWidth * devicePixelRatio);
        canvas.height = Math.floor(canvas.clientHeight * devicePixelRatio);
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
        if (currentKey) {
          drawSpectrum(spectraData[currentKey]);
          drawSpectrumRainbow(spectraData[currentKey], document.getElementById('canvasRainbow'));
        }
      }
      window.addEventListener('resize', debounce(resize, 120));
      resize();
    }

    function drawSpectrum(spectrum) {
      if (!spectrum || !Array.isArray(spectrum.wavelength) || !Array.isArray(spectrum.flux)) {
        showMessage('Cannot draw: spectrum missing fields.', true);
        console.warn('drawSpectrum: bad spectrum:', spectrum);
        return;
      }
      const wl = spectrum.wavelength;
      const fx = spectrum.flux;
      if (wl.length !== fx.length || wl.length < 2) {
        showMessage('Wavelength and flux arrays differ in length (or too short).', true);
        console.log('wl.length', wl.length, 'fx.length', fx.length);
        return;
      }

      // size-aware drawing (CSS pixel -> device pixel scaling)
      const cw = canvas.clientWidth || 600;
      const ch = canvas.clientHeight || 400;
      canvas.width = Math.floor(cw * devicePixelRatio);
      canvas.height = Math.floor(ch * devicePixelRatio);
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      ctx.clearRect(0, 0, cw, ch);

      const minW = Math.min(...wl);
      const maxW = Math.max(...wl);
      const range = maxW - minW || 1.0;
      const maxF = Math.max(...fx) || 1.0;

      // layout: reserve bottom space for scale labels so text is readable
      const marginBottom = 36;    // px for scale and labels
      const topPadding = 8;
      const plotHeight = Math.max(0, ch - marginBottom - topPadding);

      ctx.lineWidth = Math.max(1, Math.round(cw / 600)); // sensible for many sizes
      ctx.lineCap = 'round';

      // draw spectrum as many small colored segments
      for (let i = 0; i < wl.length - 1; i++) {
        const x1 = ((wl[i] - minW) / range) * cw;
        const x2 = ((wl[i + 1] - minW) / range) * cw;
        const y1 = topPadding + (1 - fx[i] / maxF) * plotHeight;
        const y2 = topPadding + (1 - fx[i + 1] / maxF) * plotHeight;

        ctx.strokeStyle = wavelengthToRGBString(wl[i]);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      // small title/label (top-left)
      ctx.fillStyle = '#ddd';
      ctx.font = '12px system-ui, sans-serif';
      ctx.textBaseline = 'top';
      const minRounded = Math.round(minW);
      const maxRounded = Math.round(maxW);
      ctx.fillText(`Spectral: ${currentKey} — ${minRounded}–${maxRounded}`, 8, 8);

      // draw bottom wavelength axis/scale inside reserved margin
      drawWavelengthScale(minW, maxW, ctx, cw, ch, marginBottom);
    }

    function drawWavelengthScale(minW, maxW, ctx, cw, ch, marginBottom) {
      const range = Math.max(1e-6, maxW - minW);
      const axisBottom = ch - marginBottom + 2; // baseline for ticks (labels go below)
      const pixels = cw;

      // Choose a "nice" major step so we get a reasonable number of labels
      function chooseMajorStep(range, pixels, minLabelSpacing = 60) {
        const targetLabels = Math.max(2, Math.floor(pixels / minLabelSpacing));
        const rough = range / targetLabels;
        const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
        const candidates = [1, 2, 5, 10];
        let best = candidates[0] * pow10;
        let bestDiff = Infinity;
        for (const c of candidates) {
          const step = c * pow10;
          const diff = Math.abs(step - rough);
          if (diff < bestDiff) { best = step; bestDiff = diff; }
        }
        return best;
      }

      const majorStep = chooseMajorStep(range, pixels, 60);
      const minorStep = majorStep / 5;

      // drawing style
      ctx.strokeStyle = '#888';
      ctx.fillStyle = '#ddd';
      ctx.lineWidth = 1;
      ctx.font = '12px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';

      // spacing guard so labels don't overlap
      const pixelsPerMajor = (majorStep / range) * cw;
      const minPixelSpacing = 56;
      const labelSkip = Math.max(1, Math.ceil(minPixelSpacing / pixelsPerMajor));

      // Major ticks + labels
      let majorIndex = 0;
      const startMajor = Math.ceil(minW / majorStep) * majorStep;
      const endMajor = Math.floor(maxW / majorStep) * majorStep;
      for (let w = startMajor; w <= endMajor + 1e-9; w += majorStep) {
        const x = ((w - minW) / range) * cw;
        ctx.beginPath();
        ctx.moveTo(x, axisBottom);
        ctx.lineTo(x, axisBottom - 10);
        ctx.stroke();

        if (majorIndex % labelSkip === 0) {
          // label is only the number (no "nm") as requested
          ctx.fillText(String(Math.round(w)), x, axisBottom + 2);
        }
        majorIndex++;
      }

      // Minor ticks
      const startMinor = Math.ceil(minW / minorStep) * minorStep;
      for (let w = startMinor; w <= maxW + 1e-9; w += minorStep) {
        // skip if this aligns with a major tick
        if (Math.abs((w / majorStep) - Math.round(w / majorStep)) < 1e-6) continue;
        const x = ((w - minW) / range) * cw;
        ctx.beginPath();
        ctx.moveTo(x, axisBottom);
        ctx.lineTo(x, axisBottom - 6);
        ctx.stroke();
      }
    }

    function wavelengthToRGBString(wavelength) {
      let r = 0, g = 0, b = 0, factor = 0;
      if (wavelength >= 380 && wavelength < 440) { r = -(wavelength - 440) / (440 - 380); g = 0; b = 1; }
      else if (wavelength >= 440 && wavelength < 490) { r = 0; g = (wavelength - 440) / (490 - 440); b = 1; }
      else if (wavelength >= 490 && wavelength < 510) { r = 0; g = 1; b = -(wavelength - 510) / (510 - 490); }
      else if (wavelength >= 510 && wavelength < 580) { r = (wavelength - 510) / (580 - 510); g = 1; b = 0; }
      else if (wavelength >= 580 && wavelength < 645) { r = 1; g = -(wavelength - 645) / (645 - 580); b = 0; }
      else if (wavelength >= 645 && wavelength <= 780) { r = 1; g = 0; b = 0; }
      else { r = g = b = 0; }

      if (wavelength >= 380 && wavelength < 420) factor = 0.3 + 0.7 * (wavelength - 380) / 40;
      else if (wavelength >= 420 && wavelength <= 700) factor = 1.0;
      else if (wavelength > 700 && wavelength <= 780) factor = 0.3 + 0.7 * (780 - wavelength) / 80;
      else factor = 0.0;

      const gamma = 0.8;
      const R = Math.round(Math.pow(Math.max(0, r * factor), gamma) * 255 + 10);
      const G = Math.round(Math.pow(Math.max(0, g * factor), gamma) * 255 + 10);
      const B = Math.round(Math.pow(Math.max(0, b * factor), gamma) * 255 + 10);
      return `rgb(${R},${G},${B})`;
    }

    function debounce(fn, ms) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; }

    async function tryFetchJSON(path) {
      try {
        const res = await fetch(path, { cache: "no-cache" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return { path, json: await res.json() };
      } catch (err) {
        console.warn('fetch failed', path, err);
        return { path, error: err };
      }
    }

    function drawSpectrumRainbow(spectrum, canvasRainbow) {
      if (!spectrum || !spectrum.wavelength || !spectrum.flux) return;

      const wl = spectrum.wavelength;
      const fx = spectrum.flux;
      if (wl.length !== fx.length) {
        console.warn('Rainbow: wavelength and flux lengths differ', wl.length, fx.length);
        return;
      }

      const cw = canvasRainbow.clientWidth;
      const ch = canvasRainbow.clientHeight;

      // set canvas size in device pixels
      canvasRainbow.width = Math.floor(cw * devicePixelRatio);
      canvasRainbow.height = Math.floor(ch * devicePixelRatio);

      const ctxR = canvasRainbow.getContext('2d');
      ctxR.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      ctxR.clearRect(0, 0, cw, ch);

      const minW = Math.min(...wl);
      const maxW = Math.max(...wl);
      const maxF = Math.max(...fx); // max flux

      if (maxF === 0) return; // avoid divide by zero

      for (let i = 0; i < cw; i++) {
        const w = minW + (i / cw) * (maxW - minW);

        // nearest flux index
        let idx = wl.findIndex(v => v >= w);
        if (idx < 0) idx = wl.length - 1;

        // normalize flux to max flux
        const f = fx[idx] / maxF;

        // wavelength → RGB
        const rgb = wavelengthToRGBObj(w);
        const r = Math.floor(rgb.r * f) + 10;
        const g = Math.floor(rgb.g * f) + 10;
        const b = Math.floor(rgb.b * f) + 10;

        ctxR.fillStyle = `rgb(${r},${g},${b})`;
        ctxR.fillRect(i, 0, 1, ch);
      }
    }


    async function loadSpectraWithFallbacks() {
      showMessage('Loading spectra…');

      const candidates = ['spectra_all.json', 'spectra.json', 'spectra_all.min.json'];
      let result = null;
      for (const p of candidates) {
        result = await tryFetchJSON(p);
        if (result && result.json) break;
      }

      if (!result || result.error) {
        showMessage('Could not load any spectra JSON.', true);
        return;
      }

      spectraData = normalizeSpectra(result.json);
      keys = Object.keys(spectraData).sort(spectralComparator);

      if (keys.length === 0) {
        showMessage('JSON loaded but no spectra found.', true);
        return;
      }

      slider.max = keys.length - 1;
      slider.value = 0;
      sliderLabel.textContent = keys[0];
      loadSpectrum(keys[0]);
      showMessage(``);
    }

    function normalizeSpectra(raw) {
      const normalized = {};
      if (Array.isArray(raw)) {
        raw.forEach((entry, i) => normalized[String(i)] = entry);
      } else if (typeof raw === 'object') {
        for (const k in raw) normalized[k] = raw[k];
      }
      return normalized;
    }

    function spectralComparator(a, b) {
      const spectralOrder = ['L', 'T', 'M', 'K', 'G', 'F', 'A', 'B', 'O'];
      const matchA = a.match(/^([LTMKGFABO])(\d+)?/);
      const matchB = b.match(/^([LTMKGFABO])(\d+)?/);
      if (!matchA || !matchB) return 0;
      const idxA = spectralOrder.indexOf(matchA[1]);
      const idxB = spectralOrder.indexOf(matchB[1]);
      if (idxA !== idxB) return idxA - idxB;
      const nA = matchA[2] ? parseInt(matchA[2], 10) : 0;
      const nB = matchB[2] ? parseInt(matchB[2], 10) : 0;
      return nB - nA;
    }

    function loadSpectrum(key) {
      if (!spectraData[key]) return;
      currentKey = key;
      sliderLabel.textContent = key;
      drawSpectrum(spectraData[key]);
      drawSpectrumRainbow(spectraData[key], document.getElementById('canvasRainbow'));
    }

    function showMessage(txt, isErr = false) {
      messageEl.textContent = txt;
      messageEl.style.color = isErr ? 'var(--err)' : 'var(--muted)';
    }

    function wavelengthToRGBObj(wavelength) {
      let r = 0, g = 0, b = 0, factor = 0;

      if (wavelength >= 380 && wavelength < 440) { r = -(wavelength - 440) / 60; g = 0; b = 1; }
      else if (wavelength >= 440 && wavelength < 490) { r = 0; g = (wavelength - 440) / 50; b = 1; }
      else if (wavelength >= 490 && wavelength < 510) { r = 0; g = 1; b = -(wavelength - 510) / 20; }
      else if (wavelength >= 510 && wavelength < 580) { r = (wavelength - 510) / 70; g = 1; b = 0; }
      else if (wavelength >= 580 && wavelength < 645) { r = 1; g = -(wavelength - 645) / 65; b = 0; }
      else if (wavelength >= 645 && wavelength <= 780) { r = 1; g = 0; b = 0; }
      else { r = g = b = 0; }

      if (wavelength >= 380 && wavelength < 420) factor = 0.3 + 0.7 * (wavelength - 380) / 40;
      else if (wavelength >= 420 && wavelength <= 700) factor = 1.0;
      else if (wavelength > 700 && wavelength <= 780) factor = 0.3 + 0.7 * (780 - wavelength) / 80;
      else factor = 0.0;

      const gamma = 0.8;
      return {
        r: Math.pow(r * factor, gamma) * 255 + 10,
        g: Math.pow(g * factor, gamma) * 255 + 10,
        b: Math.pow(b * factor, gamma) * 255 + 10
      };
    }

    // 🔽 your existing drawSpectrum, drawSpectrumRainbow, wavelengthToRGB functions remain unchanged
  </script>
</body>

</html>